<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.4.549">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Haly-en">
<meta name="dcterms.date" content="2023-02-16">

<title>☂️ About me - herramientas interesantes</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<script src="../../site_libs/quarto-html/quarto.js"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>
<style>html{ scroll-behavior: smooth; }</style>


<link rel="stylesheet" href="../../styles.css">
</head>

<body class="nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top quarto-banner">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title">☂️ About me</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../about.html"> 
<span class="menu-text">Recursos</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../blog.html"> 
<span class="menu-text">BLog</span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/Haly-en"> <i class="bi bi-github" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://twitter.com/HalyHalymary"> <i class="bi bi-twitter" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
          <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<header id="title-block-header" class="quarto-title-block default page-columns page-full">
  <div class="quarto-title-banner page-columns page-full">
    <div class="quarto-title column-body">
      <h1 class="title">herramientas interesantes</h1>
                                <div class="quarto-categories">
                <div class="quarto-category">code</div>
                <div class="quarto-category">data</div>
              </div>
                  </div>
  </div>
    
  
  <div class="quarto-title-meta">

      <div>
      <div class="quarto-title-meta-heading">Author</div>
      <div class="quarto-title-meta-contents">
               <p>Haly-en </p>
            </div>
    </div>
      
      <div>
      <div class="quarto-title-meta-heading">Published</div>
      <div class="quarto-title-meta-contents">
        <p class="date">February 16, 2023</p>
      </div>
    </div>
    
      
    </div>
    
  
  </header><div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#indice" id="toc-indice" class="nav-link active" data-scroll-target="#indice">Indice</a></li>
  <li><a href="#modelo-de-herramientas-necesarias" id="toc-modelo-de-herramientas-necesarias" class="nav-link" data-scroll-target="#modelo-de-herramientas-necesarias">Modelo de Herramientas necesarias</a></li>
  <li><a href="#transformaciones" id="toc-transformaciones" class="nav-link" data-scroll-target="#transformaciones">Transformaciones</a></li>
  <li><a href="#visualizaciones" id="toc-visualizaciones" class="nav-link" data-scroll-target="#visualizaciones">Visualizaciones</a></li>
  <li><a href="#modelado" id="toc-modelado" class="nav-link" data-scroll-target="#modelado">Modelado</a></li>
  <li><a href="#comunicacion" id="toc-comunicacion" class="nav-link" data-scroll-target="#comunicacion">Comunicacion</a></li>
  <li><a href="#tidyverse" id="toc-tidyverse" class="nav-link" data-scroll-target="#tidyverse">Tidyverse</a></li>
  <li><a href="#prerequisitos" id="toc-prerequisitos" class="nav-link" data-scroll-target="#prerequisitos">Prerequisitos</a></li>
  <li><a href="#dplyr" id="toc-dplyr" class="nav-link" data-scroll-target="#dplyr">dplyr</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content quarto-banner-title-block" id="quarto-document-content">





<p>La ciencia de datos es una disciplina emocionante que permite convertir los datos sin procesar, en conocimiento.</p>
<p>En esta sesión daremos una mirada a Tidyverse, y específicamente a dplyr para ordenar y trabajar con datos con miras a analizarlos.</p>
<section id="indice" class="level1">
<h1>Indice</h1>
<ul>
<li>Introducción</li>
<li>Modelo de Herramientas necesarias</li>
<li>Paquete dplyr</li>
<li>filter()</li>
<li>Select()</li>
<li>Mutate()</li>
<li>summarize()</li>
<li>group_by()</li>
<li>Uso de pipes</li>
<li>alternativas para el uso de pipes</li>
<li>cuando no usar pipes</li>
<li>Tpipes.</li>
</ul>
<p>Los datos con los que vamos a trabajar se encuentran <a href="http://www.uusmb.unam.mx/Cursos/Tidyverse/Data/msleep_ggplot2.csv">aqui: msleep_ggplot2.csv</a> El protocolo con comandos de esta clase se encuentran <a href="http://www.uusmb.unam.mx/Cursos/Tidyverse/TidyverseProtocolo.R">aca: TidyverseProtocolo.R</a></p>
</section>
<section id="modelo-de-herramientas-necesarias" class="level1">
<h1>Modelo de Herramientas necesarias</h1>
<p>“La exploración de los datos es el arte de mirar en tus datos, generar hipotesis, probar o desechar dichas hipotesis y volver a repetir…”</p>
<p>Fuente: http://r4ds.had.co.nz/introduction.html</p>
<ul>
<li>La información ordenada es importante porque la estructura coherente nos permite centrar el esfuerzo en las preguntas sobre los datos, no luchando para obtener los datos en la forma correcta para las diferentes funciones…</li>
<li>Por ejemplo considere un formato Genebank como fuente de nuestra información de entrada:</li>
<li>El primer esfuerzo será ordenar la información de manera que en cada renglon tengamos la descripción de un objeto y en cada columna los atributos para describir los objetos:</li>
</ul>
</section>
<section id="transformaciones" class="level1">
<h1>Transformaciones</h1>
<ul>
<li>La transformación incluye resumir las observaciones de interés (como todas las personas en una ciudad, o todos los datos del último año), crear nuevas variables que son funciones de variables existentes (como calculo de la velocidad, a partir de la distancia y tiempo) y calcular un summary estadístico.</li>
<li>Las transformaciones permiten seleccionar variables importantes, filtrar obsevaciones, crear nuevas variables y generar resumenes.</li>
</ul>
</section>
<section id="visualizaciones" class="level1">
<h1>Visualizaciones</h1>
<ul>
<li>La visualización es una actividad fundamentalmente humana.</li>
<li>Una buena visualización muestra cosas que no esperabas, o plantea nuevas preguntas sobre los datos. Te debe ayudar a entender tus datos</li>
<li>Una buena visualización también podría indicar que estas haciendo la pregunta incorrecta, o necesita recolectar datos diferentes.</li>
<li>Las visualizaciones pueden sorprenderte, pero no escalan particularmente bien porque requieren un ser humano para interpretarlas.</li>
</ul>
</section>
<section id="modelado" class="level1">
<h1>Modelado</h1>
<ul>
<li><p>Los modelos son herramientas complementarias para la visualización.</p></li>
<li><p>Una vez que hayas hecho las preguntas lo suficientemente precisas, puedes usar un modelo para responderlas.</p></li>
<li><p>Los modelos son una herramienta fundamentalmente matemática o computacional, por lo que generalmente se escalan bien.</p></li>
<li><p>Incluso cuando no lo hacen, generalmente es más barato comprar más computadoras que comprar más cerebros</p></li>
</ul>
</section>
<section id="comunicacion" class="level1">
<h1>Comunicacion</h1>
<ul>
<li><p>No importa qué tan bien tus modelos y visualización te hayan llevado a comprender los datos a menos que también puedas comunicar tus resultados a otros.</p></li>
<li><p>No necesitas ser un programador experto para ser un científico de datos, peroooo… aprender más acerca de la programación vale la pena porque convertirse en un mejor programador te permite automatizar tareas comunes y resolver nuevos problemas con mayor facilidad.</p></li>
</ul>
</section>
<section id="tidyverse" class="level1">
<h1>Tidyverse</h1>
</section>
<section id="prerequisitos" class="level1">
<h1>Prerequisitos</h1>
<ul>
<li>Primero debemos tener instalado el tidyverse: install.packages(‘tidyverse’) library(tidyverse)</li>
</ul>
</section>
<section id="dplyr" class="level1">
<h1>dplyr</h1>
<ul>
<li><p>dplyr es un poderoso paquete de R para transformar y sumarizar datos tabulares en R</p></li>
<li><p>Tiene un conjunto de funciones (o verbos) que realizan las operaciones mas comunes en el análisis de datos como son :</p>
<ul>
<li><p>Filtrar por renglones</p></li>
<li><p>Seleccionar columnas especificas</p></li>
<li><p>Reordenar renglones</p></li>
<li><p>Adicionar nuevas columnas</p></li>
<li><p>Sumarizar datos</p></li>
</ul></li>
<li><p>Casi todas las funciones que utilizará en este libro producen tibbles, ya que los tibbles son una de las características unificadoras del tidyverse. La mayoría de los otros paquetes R usan dataframes(), por lo que es posible que forzemos la conversion de un dataframe a un tibble. Puedes hacer eso con as_tibble ().</p></li>
<li><p>tibble () reciclará automáticamente las entradas de longitud 1, y le permite consultar las variables que acaba de crear, como se muestra a continuación.</p></li>
</ul>
<p>Data: msleep_ggplot2.csv</p>
<p>Para esta sesión trabajaremos con esta tabla que contiene los tiempos de sueño y peso de un conjunto de 83 mamíferos, descritos con las siguientes 11 columnas * name common name</p>
<ul>
<li><p>genus taxonomic rank</p></li>
<li><p>vore carnivore, omnivore or herbivore?</p></li>
<li><p>order taxonomic rank</p></li>
<li><p>conservation the conservation status of the mammal</p></li>
<li><p>sleep_total total amount of sleep, in hours</p></li>
<li><p>sleep_rem rem sleep, in hours (rem=rapid eye movement)</p></li>
<li><p>sleep_cycle length of sleep cycle, in hours</p></li>
<li><p>awake amount of time spent awake, in hours</p></li>
<li><p>brainwt brain weight in kilograms</p></li>
<li><p>bodywt body weight in kilograms</p></li>
</ul>
<p>Primero, verificaremos donde estamos parados:</p>
<p>getwd()</p>
<p>Definimos donde queremos estar: setwd(“Dropbox/cursos/RLadies/Data”)</p>
<p>Leemos la tabla en formato csv msleep &lt;- read.csv(“msleep_ggplot2.csv”) head(msleep)</p>
<p>transformamos el data.frame a tibble tmsleep&lt;-as_tibble(msleep)</p>
<p>Existen 5 funciones claves para transformar datos con dplyr que permiten resolver la mayoría de los retos en el proceso de manipulación de datos:</p>
<ul>
<li><p>Elegir las observaciones por sus valores (filter())</p></li>
<li><p>Reordenar los renglones (arrange())</p></li>
<li><p>Elegir las variables por sus nombres (select())</p></li>
<li><p>Crear nuevas variables con funciones sobre las variables existentes (mutate())</p></li>
</ul>
<p>*Colapsar muchos valores en un resumen de los mismos (summarise())</p>
<p>Estas funciones pueden ser usadas en conjunción con group_by() la cual cambia el ámbito de cada función para operar sobre el conjunto completo de datos u operando solo grupo por grupo.</p>
<p>GroupBy</p>
<p>dplyr puede ser vista como una gramatica de manipulación de datos, donde cada función es un verbo y cada verbo trabaja de manera similar:</p>
<ol type="1">
<li><p>El primer argumento es el nombre del data.frame o tibbies</p></li>
<li><p>Los siguiente argumentos describen que se hace con el data.frame usando los nombres de variables.</p></li>
<li><p>El resultado es un nuevo data.frame o tibbies</p></li>
</ol>
<p>Filtrando elementos con filter()</p>
<p>Filter() permite filtrar observaciones a partir de sus valores. El primer argumento es el nombre de data frame. El segundo y los siguientes argumentos son las expresiones de filtro. Por ejemplo: Filtremos a todos los mamíferos carnívoros que duerman mas de 10 horas filter(tmsleep,vore==‘carni’,sleep_total&gt;10)</p>
<p>*dplyr nunca modifica sus entradas, así que si quieres guardar el resultado necesitas usar el operador &lt;-</p>
<ul>
<li>R imprime los resultados o los salva en una variable. Si quieres hacer ambos debes hacer la asignación entre paréntesis:</li>
</ul>
<p>(Carnivoros&lt;-filter(tmsleep,vore==‘carni’,sleep_total&gt;10))</p>
<p>Para usar el filtro efectivamente, debes conocer como seleccionar los objetos que deseas usando los operadores de comparación:</p>
<pre><code>     &gt;  ,   &lt;  ,   &gt;=  ,  &lt;   ,  &lt;=  ,  !=  , ==</code></pre>
<p>Es muy común el error de instanciar == con =</p>
<p>(Carnivoros&lt;-filter(tmsleep,vore=‘carni’,sleep_total&gt;10))</p>
<ul>
<li>Otro error común es hacer comparaciones de igualdad con puntos flotantes. Los siguientes resultados pueden ser sorpresivos para ti sqrt(2) ^ 2 == 2 [1] FALSE 1 / 49 * 49 == 1 [1] FALSE</li>
</ul>
<p>Operadores Logicos</p>
<ul>
<li><p>Múltiples argumentos de filter() son combinados con “and” : todas las condiciones deben ser verdaderas para incluir el renglón en la salida</p></li>
<li><p>Se pueden usar los siguientes operadores booleanos: &amp; es “and”, “|” es “or”, y ! es “not”.</p></li>
</ul>
<p><img src="images/DiagramasVenn.png"></p>
<ul>
<li>El siguiente código encuentra todos los animales del orden taxonómico del Perissodactyla o Primates (suborder&lt;- filter(tmsleep, order==“Perissodactyla” | order==“Primates”))</li>
</ul>
<p>Un forma util de hacer preguntas de mas de un valor para la misma variables es usando x %in% y</p>
<p>(suborder&lt;- filter(tmsleep, order %in% c(“Perissodactyla”,“Primates”)))</p>
<p>Algunas veces se pueden simplificar la generación de subconjuntos complicados por recordar la ley de morgan:</p>
<pre><code>         !(x &amp; y) es  lo mismo que !x | !y

         !(x | y) es lo mismo que !x &amp; !y</code></pre>
<p>Por ejemplo:</p>
<p>obtener todos los mamiferos que no duermen menos 10 horas ni tienen periodos de movimiento ocular rápido (rem) menores a 1 hora</p>
<p>(subsleep&lt;- filter(tmsleep, !(sleep_total &lt; 10), !(sleep_rem &lt; 1 ))) (subsleep&lt;- filter(tmsleep, !(sleep_total &lt; 10 | sleep_rem &lt; 1 )))</p>
<p>Ordenando renglones con arrange()</p>
<ul>
<li><p>Arrange() trabaja similar a filter() excepto que en lugar de seleccionar renglones, cambia su orden.</p></li>
<li><p>Ordena los renglones de un data.frame a partir de un conjunto de columnas especificadas (o una expresión mas complicada)</p></li>
<li><p>Si seleccionas mas de una columna, cada columna adicional será ordenada en dependencia de los valores de la columna anterior</p></li>
</ul>
<p>Ordenamos en función del peso del cerebro, el peso del cuerpo, el total de horas que se duerme y el tiempo de rem:</p>
<p>arrange(tmsleep, brainwt, bodywt, sleep_total,sleep_rem)</p>
<p>Los valores perdidos siempre se ordenan al final</p>
<p>df &lt;- tibble(x = c(1, 10,NA, 3)) arrange(df, x) arrange(df, desc(x))</p>
<p>Seleccionando columnas con select()</p>
<ul>
<li><p>No es poco común tener conjuntos de datos con miles o varios cientos de variables. En este caso, lo primero que queremos cambiar es enfocarnos en las variables en las que estamos interesados en este momento.</p></li>
<li><p>Select() nos permite hacer un “zoom” en un subconjunto usando operaciones sobre los nombres de las variables</p></li>
</ul>
<p>Seleccionemos solo el nombre, el peso del cerebro, el peso del cuerpo y el total de horas que se duerme…</p>
<p>select(tmsleep, name, brainwt,bodywt,sleep_total)</p>
<p>Seleccionemos del nombre a la conservación:</p>
<p>select(tmsleep, name:conservation)</p>
<p>Seleccionemos todas excepto de genero a nombre a la conservación:</p>
<p>select(tmsleep, -(genus:conservation))</p>
<p>Existen un grupo de funciones útiles que pueden usarse dentro de select():</p>
<ul>
<li><p>starts_with(“abc”): nombres que empiezan con “abc”.</p></li>
<li><p>ends_with(“xyz”): nombres que terminan con “xyz”.</p></li>
<li><p>contains(“ijk”): nombres que contienen “ijk”.</p></li>
<li><p>matches(“(.)\1”): selecciona variables que hacen match con una expresión regular.</p></li>
<li><p>num_range(“x”, 1:3): hace match con x1, x2 y x3.</p></li>
</ul>
<p>Ver ?select para mas detalles</p>
<p>Agregando nuevas variables con mutate()</p>
<ul>
<li><p>Además de seleccionar conjuntos de columnas existentes, es frecuentemente util adicionar nuevas columnas que son funciones de las columnas existentes. Ese es el trabajo de mutate()</p></li>
<li><p>mutate() permite adicionar nuevas columnas al final de tu dataset asi que empezaremos creando un conjunto de datos mas estrecho para que podamos ver las nuevas variables</p></li>
<li><p>Recuerda que en R Studio la manera mas facil de ver todas las columnas es con View()</p></li>
</ul>
<p>Generemos una nueva tabla con el nombre, todas las columnas que inicen con sleep, y la columna awake</p>
<p>(sleep_sml&lt;-select(tmsleep, name,starts_with(“sleep”),awake))</p>
<p>Y agreguemos dos columnas: mutate(sleep_sml, total= sleep_total+awake, prop=sleep_rem/sleep_total)</p>
<p>mutate(sleep_sml,prop=sleep_rem/sleep_total, porcent=prop*100)</p>
<p>transmute()</p>
<p>Si solo quieres conservar las variables que acabas de crear, usa transmute()</p>
<p>transmute(sleep_sml,prop=sleep_rem/sleep_total, porcent=prop*100)</p>
<p>Resumenes Agrupados El ultimo verbo es summarize(). Colapsa un data.frame a un simple renglón:</p>
<p>summarize(sleep_sml, sleep=mean(sleep_total),brain=mean(sleep_rem))</p>
<p>Para evitar el NA:</p>
<p>summarize(sleep_sml, sle=mean(sleep_total),br=mean(sleep_rem,na.rm=TRUE))</p>
<p>summarise() es mucho mas util cuando se usa a la par de group_by. Esto cambia la unidad de análisis del grupo completo de datos a grupos individuales.</p>
<p>vore&lt;-group_by(msleep,vore) summarize(vore,mean(sleep_total),mean(sleep_rem,na.rm=TRUE))</p>
<p>Y eso es todo…</p>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->
<footer class="footer">
  <div class="nav-footer">
    <div class="nav-footer-left">
<p>-Haly-en-</p>
</div>   
    <div class="nav-footer-center">
      &nbsp;
    </div>
    <div class="nav-footer-right">
      &nbsp;
    </div>
  </div>
</footer>




<script src="../../site_libs/quarto-html/zenscroll-min.js"></script>
</body></html>